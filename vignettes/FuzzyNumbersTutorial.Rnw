%\VignetteIndexEntry{A Guide to the FuzzyNumbers Package}
%\VignetteEngine{knitr::knitr}
%\VignetteKeyword{fuzzy number}
%\VignetteKeyword{extension principle}
%\VignetteKeyword{S4}
\documentclass[11pt]{article}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\usepackage[dvips,a4paper,left=2.5cm,right=2.5cm,foot=1.0cm,
   headheight=1.0cm,top=2.0cm,margin=2.5cm]{geometry}
\linespread{1.1}

\usepackage{fancyhdr}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\selectlanguage{english}
\usepackage{xspace}
\usepackage{lmodern}

\usepackage{amsmath,amssymb,amsfonts}
\RequirePackage{graphicx,verbatim,longtable}
\usepackage{mdwlist}
\usepackage[nottoc]{tocbibind}
\usepackage{rotating}

\newcommand{\email}[1]{\href{mailto:#1}{#1}}
\renewcommand{\emph}[1]{\textsl{#1}}
\newcommand{\indicator}{\text{\bf 1}}
\renewcommand{\Pr}{\mathrm{P}}
\renewcommand{\ln}{\mathrm{ln}\,}

\newcommand{\package}[1]{\textsf{#1}\xspace}
\newcommand{\program}[1]{\textsf{#1}\xspace}
\newcommand{\os}[1]{\textsf{#1}\xspace}
\newcommand{\lang}[1]{\textsf{#1}\xspace}
\newcommand{\Cpp}{\lang{C++}}
\newcommand{\R}{\lang{R}}

\newcommand{\func}[1]{\texttt{\hlkwd{#1}}}
\newcommand{\argument}[1]{\texttt{\hlkwc{#1}}}
\newcommand{\str}[1]{\texttt{\hlstr{#1}}}
\newcommand{\key}[1]{{$\langle$\texttt{#1}$\rangle$}\xspace} % skrot klawiszowy

\setlength{\pdfpagewidth}{\paperwidth}
\setlength{\pdfpageheight}{\paperheight}


\usepackage{xcolor}
\definecolor{blue2}{rgb}{0,0.2,0.7}
\definecolor{red2}{rgb}{0.4,0.1,0.1}
\usepackage{colortbl}
\definecolor{navy}{rgb}{0,0.0,0.4}
\definecolor{navy2}{rgb}{0.4,0.1,0.3}
\definecolor{red2}{rgb}{0.6,0.1,0.2}
\definecolor{green2}{rgb}{0.1,0.4,0.2}

\usepackage{hyperref}

\usepackage{caption}
\captionsetup{font=small,labelfont=bf,labelsep=period,justification=centering}
\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Tab.}}


\setlength{\topsep}{1pt} % wplywa m.in. na odstep dla verbatim
\tolerance=500
\predisplaypenalty=0
\clubpenalty=1000
\widowpenalty=1000


\newif\ifDevelopmentVersion

<<FNver,echo=FALSE,results='asis',cache=FALSE>>=
FNver <- packageDescription("FuzzyNumbers")$Version
if (as.integer(substring(FNver, nchar(FNver))) == "0") {
   cat("\\DevelopmentVersiontrue\n")
} else {
   cat("\\DevelopmentVersionfalse\n")
}
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\ifDevelopmentVersion
\pagestyle{fancy}
\fancyhead[L]{}
\fancyhead[R]{}
\fancyhead[C]{\footnotesize\sf This tutorial reflects the state of the most
recent development version
of \package{FuzzyNumbers} available on
\href{https://github.com/Rexamine/FuzzyNumbers}{\textit{GitHub}}.\newline
If you use the ``official'' CRAN release, some of the features may be unavailable.}
\fi

\begin{document}
%\SweaveOpts{concordance=TRUE}



\begin{center}
{\LARGE\sf A Guide to the \package{FuzzyNumbers} Package for \R}

{\Large\sf (FuzzyNumbers version {\Sexpr{FNver}}) }

\bigskip
{\large Marek Gagolewski${}^{1,2}$}

${}^{1}$ Systems Research Institute, Polish Academy of Sciences

ul. Newelska 6, 01-447 Warsaw, Poland

${}^{2}$ Rexamine, Email: \texttt{gagolews@rexamine.com}

{\large Jan Caha${}^{3}$}

${}^{3}$ Institute of Geoinformatics, VÅ B - Technical University of Ostrava

Email: \texttt{jan.caha@klikni.cz}

\bigskip

\href{http://FuzzyNumbers.rexamine.com/}%
{http://FuzzyNumbers.rexamine.com}

\bigskip
\today



\medskip
\textit{Any suggestions and contributions are welcome!}
\end{center}





\bigskip\hrule\bigskip
\tableofcontents

<<echo=FALSE,results='hide',warning=FALSE,message=FALSE,cache=FALSE>>=
options(digits=7)
options(width=73)
require('knitr')
# require('tikzDevice')
#
# options(tikzDefaultEngine = 'pdftex')
#
# options(tikzLatexPackages = c( # dolaczanie uzywanych pakietow TeX-a
#    '\\usepackage{amsmath,amssymb,amsfonts}', # pakiety AMS
#    '\\usepackage{tikz}',
# #   '\\usepackage[MeX,T1,plmath]{polski}', # obsluga m.in. polskich ogonkow
#    '\\usepackage[utf8]{inputenc}',
#    '\\usepackage[T1]{fontenc}',
#    '\\usetikzlibrary{calc}',
#    '\\usepackage[english]{babel}',
#    '\\selectlanguage{english}',
#    '\\usepackage{standalone}'
# ))
#
# options(tikzMetricsDictionary='~/R/tikzMetrics')
#
# options(tikzDocumentDeclaration = '\\documentclass[11pt]{standalone}\n')
#
# options(tikzMetricPackages = c(
#    '\\usepackage[utf8]{inputenc}',
#    '\\usepackage[T1]{fontenc}',
#    '\\usepackage{amsmath,amssymb,amsfonts}',
#    '\\usetikzlibrary{calc}',
#    '\\usepackage[english]{babel}',
#    '\\selectlanguage{english}'
# ))



# opts_knit$set(progress = TRUE, verbose = TRUE)

opts_chunk$set(
   keep.source=TRUE,
   out.width='4.5in',
   fig.width=6,
   fig.height=6/sqrt(3),
#    fig.path='figures-knitr/',
#    cache.path='cache-knitr/',
   cache=TRUE,
   tidy=FALSE,
#    dev='cairo_pdf',
#    dev.args=list(pointsize=11),
#    dev='tikz',
#    external=TRUE,
   fig.align='center',
   size='small'
)

# knit_theme$set(knit_theme$get('solarized-light'))
@

% \definecolor{fgcolor}{gray}{0}
% \renewcommand{\hlnumber}[1]{\textcolor[gray]{0.2}{#1}}%
% \renewcommand{\hlfunctioncall}[1]{\textbf{#1}}%
% \renewcommand{\hlstring}[1]{\textcolor[gray]{0.2}{\textit{#1}}}%
% \renewcommand{\hlkeyword}[1]{\textbf{#1}}%
% \renewcommand{\hlargument}[1]{\textcolor[rgb]{0.2,0.2,0.2}{\textsl{#1}}}%
% \renewcommand{\hlcomment}[1]{\textcolor[gray]{0.5}{\it\textsf{#1}}}%
% \renewcommand{\hlroxygencomment}[1]{\textcolor[gray]{0.5}{\it\textsf{#1}}}%
% \renewcommand{\hlformalargs}[1]{\textcolor[rgb]{0.69,0.25,0.03}{#1}}%
% \renewcommand{\hleqformalargs}[1]{\textcolor[rgb]{0.69,0.25,0.03}{#1}}%
% \renewcommand{\hlassignement}[1]{\textcolor[gray]{0}{\textbf{#1}}}%
% \renewcommand{\hlpackage}[1]{\textcolor[rgb]{0.59,0.71,0.15}{#1}}%
% \renewcommand{\hlslot}[1]{\textit{#1}}%
% \renewcommand{\hlsymbol}[1]{\textcolor[cmyk]{0,0,0,1}{#1}}%
% \renewcommand{\hlprompt}[1]{\textcolor[cmyk]{0,0,0,0.5}{#1}}%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




\section{Getting Started}

Fuzzy set theory lets us quite intuitively represent
imprecise or vague information. Fuzzy numbers (FNs), introduced
by Dubois and Prade in \cite{DuboisPrade1978:opfn}, form a particular
subclass of fuzzy sets of the real line.
Formally, a fuzzy set $A$
with membership function $\mu_A:\mathbb{R}\to[0,1]$
is a fuzzy number, if it possess at least the three following properties:
\begin{itemize}
\item[(i)] it is a normalized fuzzy set,
i.e.~$\mu_A(x_0)=1$ for some $x_0\in\mathbb{R}$,
\item[(ii)] it is fuzzy convex, i.e.~for any $x_1,x_2\in\mathbb{R}$
and $\lambda\in[0,1]$ it holds
$\mu_A(\lambda x_1 + (1-\lambda) x_2) \ge \mu_A(x_1)\wedge \mu_A(x_2)$,
\item[(iii)] the support of $A$ is bounded,
where $\mathrm{supp}(A) = \mathrm{cl}(\{x\in\mathbb{R}: \mu_A(x)>0\})$.
\end{itemize}
Fuzzy numbers play a significant role
in many practical applications
(cf.~\cite{KlirYuan1995:fuzzybook})
since we often describe our knowledge about objects
through numbers, e.g. ``I'm about 180 cm tall''
or ``The rocket was launched between 2 and 3 p.m.''.




\bigskip
\package{FuzzyNumbers} is an Open Source (licensed under GNU LGPL 3)
package for \R{} -- a free software environment
for statistical computing and graphics, which
% includes an implementation
% of a very powerful and quite popular high-level language called \lang{S}.
runs on all major operating systems, i.e.~\os{Windows},
\os{Linux}, and \os{MacOS X}\footnote{%
Please visit \R Project's homepage at \href{http://www.R-project.org}{www.R-project.org}
for more details.
Perhaps you may also wish to install  \program{RStudio},
a convenient development environment for \R.
It is available at \href{http://www.rstudio.com/ide/}{www.rsudio.com/ide}.}.


\package{FuzzyNumbers} has been created in order to deal with fuzzy numbers
conveniently and effectively.
To install latest ``official'' release of the
package available on \textit{CRAN} we type%
\ifDevelopmentVersion%
\footnote{You are viewing the \textbf{development} version of the tutorial.
Some of the features presented in this document may be missing
in the current \textit{CRAN} release. Please, upgrade to the \textbf{latest} development version from
\href{https://github.com/Rexamine/FuzzyNumbers}{\textit{GitHub}}
if you need the new functionality.}\ignorespaces
\fi%
:

<<eval=FALSE>>=
install.packages('FuzzyNumbers')
@

\noindent
Alternatively, we may fetch its current development snapshot
from \href{https://github.com/Rexamine/FuzzyNumbers}{\textit{GitHub}}:

<<eval=FALSE>>=
install.packages('devtools')
library('devtools')
install_github('FuzzyNumbers', 'Rexamine')
@


\bigskip
Each session with \package{FuzzyNumbers} should be preceded by
a call to:

<<libraryFuzzyNumbers,results='hide',warning=FALSE,message=FALSE>>=
library('FuzzyNumbers') # Load the package
@

\bigskip
To view the main page of the manual we type:

<<helpFuzzyNumbers,eval=FALSE>>=
library(help='FuzzyNumbers')
@

\noindent
For more information please visit the package's homepage
\cite{Gagolewski:fuzzynumberspackage}. In case of any problems, comments,
or suggestions feel free to contact the author. Good luck!



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%





\section{How to Create Instances of Fuzzy Numbers}


\subsection{Arbitrary Fuzzy Numbers}

A fuzzy number $A$ may be defined by specifying
its core, support, and either its left/right side functions
or lower/upper $\alpha$-cut bounds. Please note that many algorithms that
deal with FNs assume we provide at least the latter, i.e.~$\alpha$-cuts.

\subsubsection{Definition by Side Functions}

A fuzzy number $A$ specified by side functions\footnote{Side functions
  are sometimes called branches or shape functions in the literature.}
has membership function of the form:
\begin{equation}
\mu_A(x) = \left\{\begin{array}{ll}
0 & \text{if } \phantom{\mathtt{a2}\le\ } x<\mathtt{a1}, \\
\mathtt{left}\left( \frac{x-\mathtt{a1}}{\mathtt{a2-a1}} \right)  & \text{if } \mathtt{a1} \le x < \mathtt{a2}, \\
1 & \text{if } \mathtt{a2}\le x\le\mathtt{a3}, \\
\mathtt{right}\left( \frac{x-\mathtt{a3}}{\mathtt{a4-a3}} \right)  & \text{if } \mathtt{a3} < x \le \mathtt{a4}, \\
0 & \text{if } \mathtt{a4}<x, \\
\end{array}\right.
\end{equation}
where $\mathtt{a1},\mathtt{a2},\mathtt{a3},\mathtt{a4}\in\mathbb{R}$,
$\mathtt{a1}\le\mathtt{a2}\le\mathtt{a3}\le\mathtt{a4}$,
$\mathtt{left}: [0,1]\to[0,1]$ is a nondecreasing function
(called the \textit{left side generator of $A$}),
and $\mathtt{right}: [0,1]\to[0,1]$ is a nonincreasing function
(\textit{right side generator of $A$}).
In our package, it is assumed that these functions fulfill the conditions
$\mathtt{left}(0)\ge 0$, $\mathtt{left}(1)\le 1$,
$\mathtt{right}(0)\le 1$, and $\mathtt{right}(1)\ge 0$.
Note that this is a so-called L-R representation of FNs,
see \cite{DuboisPrade1987:fnoverview}.



\bigskip
An example: a fuzzy number $A_1$ with linear sides
(a trapezoidal fuzzy number, see also Sec.~\ref{Sec:TFNdef}).

<<A1ex>>=
A1 <- FuzzyNumber(1, 2, 4, 7,
    left=function(x) x,
   right=function(x) 1-x
)
@

\noindent
This object is an instance of the following \R class:

<<A1ex2,dependson='A1ex'>>=
class(A1)
@

\noindent
We may print some basic information on $A_1$ by calling \texttt{\func{print}(A1)} or
simply by typing:

<<A1ex3,dependson='A1ex'>>=
A1
@

\noindent
To depict $A_1$ we call:

<<A1ex4,dependson='A1ex',fig.keep='none'>>=
plot(A1)
@

\begin{center}
<<A1ex5,dependson='A1ex',echo=FALSE>>=
par(mar=c(4,4,2,1))
plot(A1, xlab=expression(x), ylab=expression(alpha), main='')
@
\end{center}







\paragraph{Remark.}
Please note that by using side generating functions defined on $[0,1]$
% (instead of the most common approach, i.e.~ordinary side functions
% such that $l_A(x)=\frac{x-\mathtt{a1}}{\mathtt{a2-a1}}$
% and $r_A(x)=\frac{x-\mathtt{a3}}{\mathtt{a4-a3}}$)
we really make (in the author's humble opinion) the process of generating
examples for our publications much easier.
A similar concept was used e.g.~in \cite{StefaniniSorini2009:eusflat}
(LR-fuzzy numbers).

Assume, however, that we are given two fancy side
functions $f: [a_1,a_2]=[-4,-2]\to[0,1]$,
and $g: [a_3,a_4]=[-1,10]\to[1,0]$,
for example:

<<ExFconvert>>=
f <- splinefun(c(-4,-3.5,-3,-2.2,-2), c(0,0.4,0.7,0.9,1), method='monoH.FC')
g <- splinefun(c(-1,0,10), c(1,0.5,0), method='monoH.FC')
@

We should convert them to side \textit{generating} functions, which shall be
defined on the interval $[0,1]$.
This may easily be done with the \func{convertSide()}
function. It returns a new function that calls
the original one with linearly transformed input.

<<ExFconvert2,dependson='ExFconvert'>>=
convertSide(f, -4, -2)(c(0,1))
convertSide(g, -1, 10)(c(0,1))
convertSide(g, 10, -1)(c(0,1)) # interesting!
@

\noindent
These functions may be used to define a fuzzy number,
now with arbitrary support and core.

<<ExFconvert3,dependson='ExFconvert2',fig.keep='none'>>=
B <- FuzzyNumber(10,20,20,30,
    left=convertSide(f, -4, -2),
   right=convertSide(g, -1, 10)
)
plot(B, xlab=expression(x), ylab=expression(alpha))
@

\begin{center}
<<ExFconvert4,dependson='ExFconvert3',echo=FALSE>>=
par(mar=c(4,4,2,1))
<<ExFconvert3>>
@
\end{center}



\subsubsection{Definition by $\alpha$-cut Bounds}

Alternatively, a fuzzy number $A$ may be defined by specifying
its $\alpha$-cuts. We have (for $\alpha\in(0,1)$ and
$\mathtt{a1}\le\mathtt{a2}\le\mathtt{a3}\le\mathtt{a4}$):
\begin{eqnarray}
A_\alpha & := & [A_L(\alpha), A_U(\alpha)]\\
 & = & \big[
   \mathtt{a1}+(\mathtt{a2}-\mathtt{a1})\cdot\mathtt{lower}(\alpha),
   \mathtt{a3}+(\mathtt{a4}-\mathtt{a3})\cdot\mathtt{upper}(\alpha)
\big],
\end{eqnarray}
where $\mathtt{lower}: [0,1]\to[0,1]$ is a nondecreasing function
(called \textit{lower $\alpha$-cut bound generator of $A$}),
and $\mathtt{upper}: [0,1]\to[0,1]$ is a nonincreasing function
(\textit{upper bound generator}).
In our package, we assume that
$\mathtt{lower}(0)=0$, $\mathtt{lower}(1)=1$,
$\mathtt{upper}(0)=1$, and $\mathtt{upper}(1)=0$.

It is easily seen that for $\alpha\in(0,1)$ we have the following
relationship between generating functions:
\begin{eqnarray}
\mathtt{lower}(\alpha) & = & \inf\{x: \mathtt{left}(x)\ge\alpha\}, \\
\mathtt{upper}(\alpha) & = & \sup\{x: \mathtt{right}(x)\ge\alpha\}.
\end{eqnarray}
Moreover, if side generating functions are continuous and strictly
monotonic, then $\alpha$-cut bound generators are their inverses.

\bigskip\noindent
An example:

<<alphacutEx,fig.keep='none'>>=
A1 <- FuzzyNumber(1, 2, 4, 7,
    left=function(x) x,
   right=function(x) 1-x
)
A2 <- FuzzyNumber(1, 3, 4, 7,
   lower=function(alpha) pbeta(alpha, 5, 9), # CDF of a beta distr.
   upper=function(alpha) pexp(1/alpha-1) # transformed CDF of an exp. distr.
)
plot(A1, col='blue')
plot(A2, col='red', lty=2, add=TRUE)
legend('topright', c(expression(mu[A1]), expression(mu[A2])),
   col=c('blue', 'red'), lty=c(1,2))
@

\begin{center}
<<alphacutEx2,dependson='alphacutEx',echo=FALSE>>=
par(mar=c(4,4,2,1))
plot(A1, col='blue', xlab=expression(x), ylab=expression(alpha))
plot(A2, col='red', lty=2, add=TRUE)
legend('topright', expression(mu[A[1]], mu[A[2]]),
   col=c('blue', 'red'), lty=c(1,2))
@
\end{center}




\paragraph{Remark.}
The \func{convertAlpha()} function
works similarly to \func{convertSide()}.
It scales the output values
of a given function, thus it may be used to create
an $\alpha$-cut generator conveniently.

\subsubsection{Definition with Generating Functions Omitted: Shadowed Sets}

In the above examples
either side generating functions or $\alpha$-cut generators
were passed to the \func{FuzzyNumber()} function.
Let us note what will happen if we omit both of them.

<<A3def>>=
A3 <- FuzzyNumber(1, 2, 4, 5)
A3
@

\noindent
The object seems to be defined correctly: \R does not make any
complaints. However\dots

<<A3deffig,dependson='A3def',fig.keep='none'>>=
plot(A3)
@

\begin{center}
<<A3deffig2,dependson='A3def',echo=FALSE>>=
par(mar=c(4,4,2,1))
plot(A3, xlab=expression(x), ylab=expression(alpha), shadowcol='gray')
@
\end{center}

\noindent
It turns out that we have obtained a \textit{shadowed set}!
Indeed, this behavior is quite reasonable: we have provided no information
on the ``partial knowledge'' part of our fuzzy number.
In fact, the object has been initialized
with generating functions always returning \texttt{NA}
(\textit{Not-Available} or \textit{any} value).
Does it mean that when we define a FN solely by side generators, we
cannot compute its $\alpha$-cuts? Indeed!

<<alphacutEx3,dependson='alphacutEx'>>=
alphacut(A2, 0.5) # A2 has alpha-cut generators defined
alphacut(A1, 0.5) # A1 hasn't got them
@

\noindent
Another example: evaluation of the membership function.

<<alphacutEx4,dependson='alphacutEx'>>=
evaluate(A1, 6.5) # A1 has side generators defined
evaluate(A2, 6.5) # A2 hasn't got them
@

\subsection{Using Numeric Approximations of $\alpha$-cut or Side Generators}

The reason for setting
\texttt{NA}s\footnote{To be precise, it's \texttt{NA\_real\_}.}
as return values of omitted generators
is simple. Finding a function inverse numerically
requires lengthy computations and is always done locally
(for a given point, not for ``whole'' the function at once).
\R is not a symbolic mathematical solver.
If we had defined such procedures (it is really easy to do
by using the \func{uniroot()} function), then an inexperienced user
would have used it in his/her algorithms and wondered why everything
runs so slow. To get more insight, let us look at the internals of \texttt{A2}:

<<alphacutEx5,dependson='alphacutEx'>>=
A2['lower']
A2['upper']
A2['left']
A2['right']
@

\noindent
Note that all generators are properly vectorized (for
input vectors of length $n$ they always give output of the
same length).
Thus, general rules are as follows.
If you want $\alpha$-cuts (e.g.~for finding
trapezoidal approximations of FNs), specify them.
If you would like to calculate the membership function (by the way,
the \func{plot()} function
automatically detects what kind of knowledge we have),
assure the side generators are provided.


However, we also provide a convenient short-cut method
to \textit{interpolate} generating functions of one type
to get some crude numeric approximations of their inverses:
the \func{approxInvert()}
function\footnote{The
\argument{n} argument, which sets the number of interpolation points,
controls the trade-off between accuracy and computation speed.
Well, world's not ideal, remember that ``some'' is better than ``nothing''
sometimes.}, which may
of course be applied on results returned by
\func{convertAlpha()}
and \func{convertSide()}.
This is a simple wrapper to \R's \func{approxfun()}
(piecewise linear interpolation,
the \str{'{}linear'{}} \argument{method})
and \func{splinefun()} (monotonic
splines: \argument{method}s \str{'{}hyman{}'}
and \str{'{}monoH.FC'{}}; the latter is
default and recommended).



<<approxfuns>>=
l <- function(x) pbeta(x, 1, 2)
r <- function(x) 1-pbeta(x, 1, 0.1)
A4 <- FuzzyNumber(-2, 0, 0, 2,
   left  = l,
   right = r,
   lower = approxInvert(l),
   upper = approxInvert(r)
)

x <- seq(0,1,length.out=1e5)
max(abs(qbeta(x, 1, 2) - A4['lower'](x)))     # sup-error estimator
max(abs(qbeta(1-x, 1, 0.1) - A4['upper'](x))) # sup-error estimator
@



% \subsection{Fuzzy Numbers with Discontinuities}\label{Sec:discontdef}
%
% We may also consider fuzzy numbers with discontinuous side
% functions or $\alpha$-cut generators.
% To avoid extensive numerical integration inaccuracies
% (i.e.~in approximation tasks, see Sec.~\ref{Sec:Approximation})
% we use objects from the \texttt{DiscontinuousFuzzyNumber} class.
% Further on we will present some examples.


% % or plotting problems....
%
% % TODO add plot for \texttt{DiscontinuousFuzzyNumber}
% % A1 <- FuzzyNumber(0,1,1,1,
% %          lower=function(a) floor(3*a)/3,
% %          upper=function(a) 1-a
% % ) # no info on discontinuities
%
% <<ExDiscontinuous>>=
% A2 <- DiscontinuousFuzzyNumber(2,3,3,3,
%          lower=function(a) floor(3*a)/3,
%          upper=function(a) 1-a,
%          discontinuities.lower=c(0, 1/3, 2/3, 1),
%          discontinuities.upper=numeric(0)
% ) # discontinuities info included
%
% integrateAlpha(A2, "lower", 0, 1)
% integrateAlpha(as.FuzzyNumber(A2), "lower", 0, 1)
% @
%
% % plots.....
%
% % integration errors without this info.... (!)
%
% ... TO BE DONE ....


\subsection{Trapezoidal Fuzzy Numbers}\label{Sec:TFNdef}

A trapezoidal fuzzy number (TFN) is a FN which has linear
side generators and linear $\alpha$-cut bound generators.
To create a trapezoidal fuzzy number $T_1$
with, for example, $\mathrm{core}(T_1)=[1.5,4]$
and $\mathrm{supp}(T_1)=[1,7]$ we call:

<<TrapEx1a>>=
T1 <- TrapezoidalFuzzyNumber(1, 1.5, 4, 7)
@

\noindent
Thus, we have:
\begin{quote}
<<TrapEx1f,dependson='TrapEx1e',results='asis',echo=FALSE>>=
cat(as.character(T1, toLaTeX=TRUE, varnameLaTeX='T_1'))
@
\end{quote}

\noindent
Note that the above equations have been automatically generated by \package{knitr}
and \LaTeX{} by
calling \texttt{\func{cat}(\func{as.character}(T1, \argument{toLaTeX=}TRUE, \argument{varnameLaTeX=}\str{'{}T\_1'{}}))},
see Sec.~\ref{Sec:Depicting}.

\noindent
The \texttt{T1} object is an instance of the following \R class:

<<TrapEx1b,dependson='TrapEx1a'>>=
class(T1)
@

\noindent
To depict $T_1$ we call:

<<TrapEx1c,dependson='TrapEx1b',fig.keep='none'>>=
plot(T1)
@

\begin{center}
<<TrapEx1d,dependson='TrapEx1c',echo=FALSE>>=
par(mar=c(4,4,2,1))
plot(T1, xlab=expression(x), ylab=expression(alpha))
@
\end{center}





\bigskip
$T_1$ is (roughly) equivalent to the trapezoidal fuzzy number $A_1$
defined in the previous subsection.
The \texttt{Trapezo\-idalFuzzyNumber}
class inherits all the goodies from the \texttt{FuzzyNumber} class,
but is more specific (guarantees faster computations,
contains more detailed information, etc.).
Of course, in this case the generating functions are known \textit{a priori}
($A_1$ had no $\alpha$-cut generators)
so there is no need to provide them manually
(what is more, this has been disallowed for safety reasons).
Thus, is we wanted to define a trapezoidal FN next time, we would
do it not like with $A_1$ but rather as with $T_1$.

<<TrapEx1e,dependson='TrapEx1d'>>=
T1['lower']
T1['upper']
T1['left']
T1['right']
@



\bigskip
Trapezoidal fuzzy numbers are among the simplest FNs.
Despite their simplicity, however, they include triangular FNs,
``crisp'' real intervals, and ``crisp'' reals.
Please note that currently no separate classes for these particular TFNs types
are implemented in the package.

<<TrapEx2>>=
TrapezoidalFuzzyNumber(1,2,2,3)   # triangular FN
TriangularFuzzyNumber(1,2,3)      # the same
TrapezoidalFuzzyNumber(2,2,3,3)   # `crisp' interval
as.TrapezoidalFuzzyNumber(c(2,3)) # the same
TrapezoidalFuzzyNumber(5,5,5,5)   # `crisp' real
as.TrapezoidalFuzzyNumber(5)      # the same
@





\subsection{Piecewise Linear Fuzzy Numbers}

Trapezoidal fuzzy numbers are generalized by piecewise linear FNs (PLFNs),
i.e.~fuzzy numbers which side generating functions and $\alpha$-cut
generators are piecewise linear functions.
Each PLFN is given by:
\begin{itemize*}
\item four coefficients $\mathtt{a1}\le\mathtt{a2}\le\mathtt{a3}\le\mathtt{a4}$
defining its support and core,
\item the number of ``knots'', \argument{knot.n}$\ge 0$,
\item a vector of $\alpha$-cut coordinates, \argument{knot.alpha}, consisting of \argument{knot.n} elements $\in[0,1]$,
\item a nondecreasingly sorted vector \argument{knot.left} consisting of \argument{knot.n} elements $\in[\mathtt{a1},\mathtt{a2}]$,
defining interpolation points for the left side function, and
\item a nondecreasingly sorted vector \argument{knot.right} consisting of \argument{knot.n} elements $\in[\mathtt{a2},\mathtt{a3}]$,
defining interpolation points for the right side function.
\end{itemize*}

If \argument{knot.n}$\ge 1$, then the membership function of
a piecewise linear fuzzy number $P$ is defined as:
\begin{equation}
\mu_P(x) = \left\{\begin{array}{ll}
0 & \text{if } \phantom{\mathtt{a2}\le\ } x<\mathtt{a1}, \\
\alpha_i+(\alpha_{i+1}-\alpha_i) \left(\frac{x-l_i}{l_{i+1}-l_i}\right)  & \text{if }\ \, l_i \le x < l_{i+1}\\
& \text{ for some } i\in\{1,\dots,n+1\}, \\
1 & \text{if } \mathtt{a2}\le x\le\mathtt{a3}, \\
\alpha_{n-i+2}+(\alpha_{n-i+3}-\alpha_{n-i+2}) \left(1-\frac{x-r_i}{r_{i+1}-r_i}\right)  & \text{if}\ \, r_i < x \le r_{i+1} \\
& \text{ for some } i\in\{1,\dots,n+1\}, \\
0 & \text{if } \mathtt{a4}<x,
\end{array}\right.
\end{equation}
and its $\alpha$-cuts for $\alpha\in[\alpha_i, \alpha_{i+1}]$
(for some $i\in\{1,\dots,n+1\}$) are given by:
\begin{eqnarray}
P_L(\alpha) & = & l_i+(l_{i+1}-l_i)\left(\frac{\alpha-\alpha_i}{\alpha_{i+1}-\alpha_i}\right), \\
P_U,(\alpha) & = & r_{n-i+2}+(r_{n-i+3}-r_{n-i+2})\left(1-\frac{\alpha-\alpha_i}{\alpha_{i+1}-\alpha_i}\right),
\end{eqnarray}
where $n=\mathtt{knot.n}$, $(l_1,\dots,l_{n+2}) = (\mathtt{a1},\mathtt{knot.left},\mathtt{a2})$,
$(r_1,\dots,r_{n+2}) = (\mathtt{a3},\mathtt{knot.right},\mathtt{a4})$,
and $(\alpha_1,\dots,\alpha_{n+2})=(0,\mathtt{knot.alpha},1)$.

\bigskip
PLFNs in our package are represented by the \texttt{PiecewiseLinearFuzzyNumber} class.

<<PLFNEx1a,fig.keep='none'>>=
P1 <- PiecewiseLinearFuzzyNumber(1, 2, 3, 4,
   knot.n=1, knot.alpha=0.25, knot.left=1.5, knot.right=3.25)
class(P1)
P1
P2 <- PiecewiseLinearFuzzyNumber(1, 2, 3, 4,
   knot.n=2, knot.alpha=c(0.25,0.6),
   knot.left=c(1.5,1.8), knot.right=c(3.25, 3.5))
P2
plot(P1, type='b', from=0, to=5, xlim=c(0.5,4.5))
plot(P2, type='b', col=2, lty=2, pch=2, add=TRUE, from=0, to=5)
@

\begin{center}
<<PLFNEx1b,dependson='PLFNEx1a',echo=FALSE>>=
par(mar=c(4,4,2,1))
plot(P1, type='b', xlab=expression(x), ylab=expression(alpha), from=0, to=5, xlim=c(0.5,4.5))
plot(P2, type='b', col=2, lty=2, pch=2, add=TRUE, from=0, to=5)
@
\end{center}

The following operators return matrices with all knots of a PLFN.
Each matrix has three columns: $\alpha$-cuts,
left side coordinates, and right side coordinates.

<<PLFNEx1c,dependson='PLFNEx1b',>>=
P1['knots']
P1['allknots'] # including a1,a2,a3,a4
@

We have, for example:
\begin{quote}
<<PLFNEx1d,dependson='PLFNEx1c',results='asis',echo=FALSE>>=
cat(as.character(P1, toLaTeX=TRUE, varnameLaTeX='P_1'))
@
\end{quote}

\bigskip
If you want to obtain a PLFN with equally distributed knots, then
you may use the more convenient version of
the \func{PiecewiseLinearFuzzyNumber()} function.

<<PLFNEx3>>=
PiecewiseLinearFuzzyNumber(knot.left=c(0,0.5,0.7,1),
                           knot.right=c(2,2.2,2.4,3))['allknots']
@

\noindent
Note that if $a_1,\dots, a_4$ are omitted, then they are taken
from \argument{knot.left} and \argument{knot.right}
(their lengths should then be equal to \argument{knot.n}+2).

\bigskip
If \argument{knot.n} is equal to 0 or all left and right knots lie on common lines,
then a PLFN reduces to a TFN.
Please note that, however, the \texttt{TrapezoidalFuzzyNumber} class
does not inherit from \texttt{PiecewiseLinearFuzzyNumber}
for efficiency reasons.
If, however, we wanted to convert an object
of the first mentioned class to the other,
we would do that by calling:

<<PLFNEx2a,fig.keep='none'>>=
alpha <- c(0.3, 0.5, 0.7)
P3 <- as.PiecewiseLinearFuzzyNumber(
   TrapezoidalFuzzyNumber(1,2.5,4,7),
         knot.n=3, knot.alpha=alpha
)
P3
plot(P3, type='b', from=-1, to=9, xlim=c(0,8))
abline(h=alpha, col='gray', lty=2)
abline(v=P3['knot.left'], col='gray', lty=3)
abline(v=P3['knot.right'], col='gray', lty=3)
text(7.5, alpha, sprintf('a=%g', alpha), pos=3)
@

\begin{center}
<<PLFNEx2b,dependson='PLFNEx2a',echo=FALSE>>=
par(mar=c(4,4,2,1))
plot(P3, type='b', xlab=expression(x), ylab=expression(alpha), from=-1, to=9, xlim=c(0,8))
abline(h=alpha, col='gray', lty=2)
abline(v=P3['knot.left'], col='gray', lty=3)
abline(v=P3['knot.right'], col='gray', lty=3)
text(7.5, alpha, parse(text=sprintf('alpha*"="*%g', alpha)), pos=3)
@
\end{center}

\noindent
More generally, each PLFN or TFN may be converted
to a direct \texttt{FuzzyNumber} class instance if needed
(hope we will never not).

<<PLFNEx2c,dependson='PLFNEx2b',>>=
(as.FuzzyNumber(P3))
@

On the other hand, to ``convert'' (with possible information loss)
more general FNs to TFNs or PLFNs, we may use the approximation
procedures described in Sec.~\ref{Sec:Approximation}.



\subsection{Fuzzy Numbers with Sides Given by Power Functions}\label{Sec:powerdef}

Bodjanova-type \cite{Bodjanova2005:medianfn}
fuzzy numbers which sides are given by power functions
are defined using four coefficients
$\mathtt{a1}\le\mathtt{a2}\le\mathtt{a3}\le\mathtt{a4}$,
and parameters $\mathtt{p.left}, \mathtt{p.right}>0$ which determine
exponents for the side functions:
\begin{eqnarray}
\mathtt{left}(x)&=&x^{\mathtt{p.left}},\\
\mathtt{right}(x)&=&(1-x)^{\mathtt{p.right}}.
\end{eqnarray}
We also have:
\begin{eqnarray}
\mathtt{lower}(\alpha)&=&\sqrt[\mathtt{p.left}]{\alpha},\\
\mathtt{upper}(\alpha)&=&1-\sqrt[\mathtt{p.right}]{\alpha}.
\end{eqnarray}
These fuzzy numbers are another natural generalization of trapezoidal FNs.

An example:
<<PowerEx1a,fig.keep='none'>>=
X <- PowerFuzzyNumber(-3, -1, 1, 3, p.left=2, p.right=0.1)
class(X)
X
plot(X)
@

\begin{center}
<<PowerEx1b,dependson='PowerEx1a',echo=FALSE>>=
par(mar=c(4,4,2,1))
plot(X, type='l', xlab=expression(x), ylab=expression(alpha))
@
\end{center}

We have:
\begin{quote}
<<PowerEx1c,dependson='PowerEx1b',results='asis',echo=FALSE>>=
cat(as.character(X, toLaTeX=TRUE, varnameLaTeX='X'))
@
\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




\section{Depicting Fuzzy Numbers}\label{Sec:Depicting}


To draw FNs we call the \func{plot()} method,
which uses similar parameters as the \R-built-in
\func{curve()} function / \func{plot.default()} method.
If you are new to \R, you may wish
to read the manual on the most popular graphical routines by
calling \texttt{?plot}, \texttt{?plot.default}, \texttt{?curve},
\texttt{?abline}, \texttt{?par}, \texttt{?lines}, \texttt{?points},
\texttt{?legend}, \texttt{?text} (some of these functions have
already been called in this tutorial).

Let us consider the following FN:

<<depicting1a,fig.keep='none'>>=
A <- FuzzyNumber(-5, 3, 6, 20,
    left=function(x) pbeta(x,0.4,3),
   right=function(x) 1-x^(1/4),
   lower=function(alpha) qbeta(alpha,0.4,3),
   upper=function(alpha) (1-alpha)^4
)
plot(A)
@

\begin{center}
<<depicting1b,dependson='depicting1a',echo=FALSE>>=
par(mar=c(4,4,2,1))
plot(A, xlab=expression(x), ylab=expression(alpha))
@
\end{center}

\paragraph{Plotting issues: discretization.}
Side functions or $\alpha$-cut bounds of objects of the \texttt{FuzzyNumber}
class (not including its derivatives) when plotted are na\"{i}vely
approximated by piecewise linear functions with equidistant knots
at one of the axes. Therefore, if we probe them
at too few points, we may obtain very rough graphical representations.
To control the number of points at which the interpolation takes place,
we use the \argument{n} argument (which defaults to \texttt{101}, i.e.~``quite
accurate'').

All three calls to the \func{plot()} method below depict the membership
function of the same fuzzy number, but with different accuracy.

<<depicting1c,dependson='depicting1b',fig.keep='none'>>=
plot(A, n=3, type='b')
plot(A, n=6, add=TRUE,  lty=2, col=2, type='b', pch=2)
plot(A, n=101, add=TRUE, lty=4, col=4) # default n
@

\begin{center}
<<depicting1d,dependson='depicting1c',echo=FALSE>>=
par(mar=c(4,4,2,1))
plot(A, n=3, type='b', xlab=expression(x), ylab=expression(alpha))
plot(A, n=6, add=TRUE, lty=2, col=2, type='b', pch=2)
plot(A, n=101, add=TRUE, lty=4, col=4) # default n
@
\end{center}




\paragraph{Making use of different generating functions' types.}
Please note (if you have not already) that to draw the membership
function we do not need to provide necessarily the FN with side generators:
the $\alpha$-cuts will also suffice.
The function is smart enough to detect the internal
representation of the FN and use the kind representation it has.
It both types of generators are given, then side functions are used.
If we want, for some reasons, to use $\alpha$-cuts, then we may do as follows:

<<depicting1e,dependson='depicting1d',fig.keep='none'>>=
plot(A, n=3, at.alpha=numeric(0), type='b') # use alpha-cuts
plot(A, n=3, type='b', col=2, lty=2, pch=2, add=TRUE) # use sides
@

\begin{center}
<<depicting1f,dependson='depicting1e',echo=FALSE>>=
par(mar=c(4,4,2,1))
plot(A, n=3, at.alpha=numeric(0), type='b', xlab=expression(x), ylab=expression(alpha)) # use alpha-cuts
plot(A, n=3, type='b', col=2, lty=2, pch=2, add=TRUE) # use side generators
@
\end{center}

\bigskip
We may also illustrate an $\alpha$-cut representation of a fuzzy number:

<<depicting1g,dependson='depicting1f',fig.keep='none'>>=
plot(A, draw.alphacuts=TRUE)
@

\begin{center}
<<depicting1h,dependson='depicting1g',echo=FALSE>>=
par(mar=c(4,4,2,1))
plot(A, draw.alphacuts=TRUE, ylab=expression(x), xlab=expression(alpha))
@
\end{center}




\paragraph{Exporting figures.}
If we would like to generate figures for our publications,
then we will surely be interested in storing them e.g.~as PDF files.
This may be done by calling:

<<A1ex6,dependson='A1ex',eval=FALSE>>=
pdf('figure1.pdf', width=8, height=5) # create file
plot(A)
dev.off() # close graphical device and save the file
@

\noindent
Postscript (PS) files are generated by substituting the call
to \func{pdf()} for the call to the \func{postcript()} function.


\paragraph{Conversion to \LaTeX.}
Another way to depict a FN is to\dots give a mathematical expression
which defines it.

<<depicting1i,dependson='depicting1h',eval=FALSE>>=
cat(as.character(A, toLaTeX=TRUE, varnameLaTeX='A'))
@

\noindent This gives the following \LaTeX{} code\dots
\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{verbatim}
<<depicting1i2,dependson='depicting1i',results='asis',echo=FALSE>>=
cat(as.character(A, toLaTeX=TRUE, varnameLaTeX='A'))
@
\end{verbatim}
\end{kframe}
\end{knitrout}

\noindent \dots and, after compiling:

\begin{quote}
<<depicting1i3,dependson='depicting1i',results='asis',echo=FALSE>>=
cat(as.character(A, toLaTeX=TRUE, varnameLaTeX='A'))
@
\end{quote}

\noindent
The code may of course be modified manually to suit your needs.

\paragraph{Tuning your figures.}
Finally, we leave you with a quite more complex graphical
example from one of our papers:

<<depicting2a,fig.keep='none'>>=
X <- PiecewiseLinearFuzzyNumber(0, 1, 2, 5, knot.n=1,
   knot.alpha=0.6, knot.left=0.3, knot.right=4)

plot.default(NA, xlab=expression(x), ylab=expression(mu[S](x)),
   xlim=c(-0.3,5.3), ylim=c(0,1)) # empty window

xpos <- c(X['a1'], X['knot.left'],  X['a2'],
          X['a3'], X['knot.right'], X['a4'])
xlab <- expression(s[1], s[2], s[3], s[4], s[5], s[6])
abline(v=xpos, col='gray', lty=3)
text(xpos, 1.05, xlab, pos=3, xpd=TRUE)

abline(h=c(0, X['knot.alpha'], 1), col='gray', lty=2)
text(5.1, X['knot.alpha'], expression(alpha[0]), pos=4, xpd=TRUE)

plot(X, add=TRUE, type='l', from=-1, to=6)
plot(X, add=TRUE, type='p', from=-1, to=6)
@

\begin{center}
<<depicting2b,dependson='depicting2a',echo=FALSE>>=
par(mar=c(4,4,2,1))
<<depicting2a>>
@
\end{center}

%\noindent
%Please note that we use \TeX{} commands in plot labels.
%They are interpreted by the \package{tikzDevice} package for \R
%to generate beautiful figures, but setting this all up requires
%higher level of skills\dots and patience.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\section{Basic Computations on and Characteristics of Fuzzy Numbers}


In this section we consider the following FN:

<<comput1a,fig.keep='none'>>=
A <- FuzzyNumber(-5, 3, 6, 20,
    left=function(x) pbeta(x,0.4,3),
   right=function(x) 1-x^(1/4),
   lower=function(alpha) qbeta(alpha,0.4,3),
   upper=function(alpha) (1-alpha)^4
)
@


\subsection{Support and Core, and Other $\alpha$-cuts}

The support of $A$, i.e.~$\mathrm{supp}(A)=[\mathtt{a1}, \mathtt{a4}]$,
may be obtained by calling:

<<comput1b,dependson='comput1a'>>=
supp(A)
@

\noindent
We get the core of $A$, i.e.~$\mathrm{core}(A)=[\mathtt{a2}, \mathtt{a3}]$,
with:

<<comput1c,dependson='comput1b'>>=
core(A)
@

\noindent
To compute arbitrary $\alpha$-cuts we use:

<<comput1d,dependson='comput1c'>>=
alphacut(A, 0) # same as supp(A) (if alpha-cut generators are defined)
alphacut(A, 1) # same as core(A)
(a <- alphacut(A, c(0, 0.5, 1)))
a[1, ]
a[2, 2]
a[, "L"]
@

\noindent
Note that \func{alphacut()} always outputs a matrix with two columns.
The matrix has named dimensions (names stand for only auxiliary information).
The \func{alphacut()} method may only be used when $\alpha$-cut generators are
provided by the user during the declaration of $A$, even for $\alpha=0$
or $\alpha=1$.

\subsection{Membership Function Evaluation}

If side generators are defined, we may calculate
the values of the membership function at different points by calling:

<<comput1e,dependson='comput1d'>>=
evaluate(A, 1)
evaluate(A, c(-3,0,3))
evaluate(A, seq(-1, 2, by=0.5))
@

% \noindent The vector has named elements (these ``labels''
% provide only auxiliary information).
% \noindent
% As wee see, this method needs a numeric vector (possibly of length 1)
% as its second parameter.


\subsection{``Typical'' Value}


Let us first introduce the notion of the \textit{expected interval} of $A$
\cite{DuboisPrade1987:meanfn}.
\begin{eqnarray}
\mathrm{EI}(A) & := & [\mathrm{EI}_L(A), \mathrm{EI}_U(A)] \\
               & = & \left[ \int_0^1 A_L(\alpha)\,d\alpha, \int_0^1 A_U(\alpha)\,d\alpha \right].
\end{eqnarray}

\noindent
To compute the expected interval of $A$ we call:

<<comput1f,dependson='comput1e'>>=
expectedInterval(A)
@

\noindent
In case of objects of
the \texttt{FuzzyNumber} class, the expected interval is approximated
by numerical integration. This method calls the \func{integrate()} function
and its accuracy (quite fine by default)
may be controlled by the \argument{subdivisions},
\argument{rel.tol}, and \argument{abs.tol} parameters
(call \texttt{?integrate} for more details).
On the other hand, for e.g.~TFNs and PLFs this method returns exact results.

\bigskip
The midpoint of the expected interval is called the \textit{expected value}
of a fuzzy number. It is given by:
\begin{equation}
\mathrm{EV}(A) := \frac{\mathrm{EI}_L(A) + \mathrm{EI}_U(A)}{2}.
\end{equation}

\noindent
Let us calculate $\mathrm{EV}(A)$.

<<comput1g,dependson='comput1f'>>=
expectedValue(A)
@

\noindent
Note that this method uses a call to \texttt{\func{expectedInterval}(A)},
thus in case of \texttt{FuzzyNumber} class instances it also uses
numerical approximation.

Sometimes a generalization of the expected value,
called \textit{weighted expected value}, is useful.
For given $w\in[0,1]$ it is defined as:
\begin{equation}
\mathrm{EV}_w(A) := (1-w)\mathrm{EI}_L(A) + w\mathrm{EI}_U(A).
\end{equation}
It is easily seen that $\mathrm{EV}_{0.5}(A)=\mathrm{EV}(A)$.

\noindent
Some examples:

<<comput1h,dependson='comput1g'>>=
weightedExpectedValue(A, 0.5) # equivalent to expectedValue(A)
weightedExpectedValue(A, 0.25)
@

\bigskip
The \textit{value} of $A$ \cite{DelgadoETAL1998:canonicalfn} is defined by:
\begin{equation}
\mathrm{val}(A) := \int_0^1 \alpha\left(A_L(\alpha)+A_U(\alpha)\right)\,d\alpha.
\end{equation}

\noindent
It may be calculated by calling:

<<comput1i,dependson='comput1h'>>=
value(A)
@

\noindent
Please note that the expected value or  value
may be used for example to ``defuzzify'' $A$.


\subsection{Measures of ``Nonspecificity''}


The \textit{width} of $A$ \cite{Chanas2001:intervapproxfn} is defined as:
\begin{equation}
\mathrm{width}(A) := \mathrm{EI}_U(A) - \mathrm{EI}_L(A).
\end{equation}

\noindent
An example:

<<comput1j,dependson='comput1i'>>=
width(A)
@

\bigskip
The \textit{ambiguity} of $A$ \cite{DelgadoETAL1998:canonicalfn} is defined as:
\begin{equation}
\mathrm{amb}(A) := \int_0^1 \alpha\left(A_U(\alpha)-A_L(\alpha)\right)\,d\alpha.
\end{equation}

<<comput1k,dependson='comput1j'>>=
ambiguity(A)
@

\bigskip
Additionally, to express ``nonspecificity'' of a fuzzy number
we may use e.g.~the width of its support:

<<comput1l,dependson='comput1k'>>=
diff(supp(A))
@



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Operations on Fuzzy Numbers}\label{Sec:Operations}

\subsection{Arithmetic Operations}

The basic binary arithmetic operations for FNs are often defined
by means of the so-called extension principle
(see \cite{KlirYuan1995:fuzzybook})
and interval arithmetic.
For each $\alpha\in[0,1]$:
\[
   (A \circledast B)_\alpha
   = A_\alpha \circledast B_\alpha,
\]
where $\circledast=+,-,*$ or $/$,
and $A,B$ are arbitrary FNs.

For example, we define the sum $A+B$  for every
$\alpha \in \lbrack 0,1]$ as:%
\[
\left( A+B\right) _{\alpha }=A_{\alpha }+B_{\alpha }=\left[ A_{L}\left(
\alpha \right) +B_{L}\left( \alpha \right) ,A_{U}\left( \alpha \right)
+B_{U}\left( \alpha \right) \right],
\]%
see \cite{DuboisPrade1978:opfn,DiamondKloeden1994:metricspacesfs}.
Moreover, for $\lambda \in \mathbb{R}$,
the scalar multiplication is given by:
\[
\left( \lambda \cdot A\right) _{\alpha }=\lambda A_{\alpha }=\left\{
\begin{array}{ll}
\left[ \lambda A_{L}\left( \alpha \right) ,\lambda A_{U}\left( \alpha
\right) \right] , & \text{if }\lambda \geq 0, \\
\left[ \lambda A_{U}\left( \alpha \right) ,\lambda A_{L}\left( \alpha
\right) \right] , & \text{if }\lambda <0,%
\end{array}%
\right.
\]%
for each $\alpha \in \lbrack 0,1]$.



In the \package{FuzzyNumbers} package we have defined
the \texttt{+}, \texttt{-}, \texttt{*} and \texttt{/} operators,
which implements the basic arithmetic operations
as defined in \cite{KlirYuan1995:fuzzybook}.


<<addition,fig.keep='none'>>=
A <- TrapezoidalFuzzyNumber(0, 1, 1, 2)
B <- TrapezoidalFuzzyNumber(1, 2, 2, 3)
plot(A, xlim=c(0,6))
plot(B, add=TRUE, col=2, lty=2)
plot(A+B, add=TRUE, col=4, lty=4)
@


\begin{center}
<<additionFig,dependson='addition',echo=FALSE,results='hide'>>=
par(mar=c(4,4,2,1))
plot(A, xlim=c(0,6), xlab=expression(x), ylab=expression(alpha))
plot(B, add=TRUE, col=2, lty=2)
plot(A+B, add=TRUE, col=4, lty=4)
legend('topright', expression(A, B, A+B), lty=c(1,2,4), col=c(1,2,4))
@
\end{center}


Currently all the operations are available
for piecewise linear FNs only,
and addition and scalar multiplication
is also implemented for trapezoidal FNs.
Note that the computer arithmetic has anyway
a discrete nature, and a PLFN with large number
of knots often approximates (cf.~Sec.~\ref{Sec:Approximation})
an arbitrary FN sufficiently well.
The computations are always exact (well, up to the computer
floating-point arithmetic errors) at knots.

In theory the class of PLFNs is not closed
under the operations \texttt{*} and \texttt{/}.
However, if you operate on a large number of knots,
the results should be satisfactory.



<<ops2>>=
A <- piecewiseLinearApproximation(PowerFuzzyNumber(1,2,3,4,p.left=2,p.right=0.5),
   method="Naive", knot.n=20)
B <- piecewiseLinearApproximation(PowerFuzzyNumber(2,3,4,5,p.left=0.1,p.right=3),
   method="Naive", knot.n=40)
A+A # the same as 2*A
A+B # note the number of knots has increased
@





\subsection{Applying Functions}


To apply a monotonic transformation on a piecewise linear fuzzy number
(using the extension principle) we call \func{fapply()}.

<<fapply,fig.keep='none'>>=
A <- as.PiecewiseLinearFuzzyNumber(TrapezoidalFuzzyNumber(0,1,2,3), knot.n=100)
plot(fapply(A, function(x) sqrt(log(x+1))))
@

\begin{center}
<<fapplyFig,dependson='fapply',echo=FALSE,results='hide'>>=
par(mar=c(4,4,2,1))
plot(fapply(A, function(x) log(x+1)^0.5), xlab=expression(x), ylab=expression(alpha))
legend('topleft', expression(sqrt(log(A+1))), lty=1)
@
\end{center}

\noindent
The operation being applied should be a properly
vectorized \R function object.

\subsubsection{Special Functions}

There are several functions that are not monotonic but useful for
calculation. Amongst those integer powers of fuzzy numbers are
probably the best example. While the odd powers could be implemented
as monotonic functions it can not be done for even powers if the
fuzzy number containts 0. Because of this issue the power is
implemented as special function.

<<exponential,fig.keep='none'>>=
A <- as.PiecewiseLinearFuzzyNumber(TrapezoidalFuzzyNumber(-2,-1,-1,2), knot.n=10)
plot(A, xlim=c(-8,8))
plot(A^2, add=TRUE, col=2, lty=2)
plot(A^3, add=TRUE, col=4, lty=4)
@

\begin{center}
<<exponentialFig,dependson='exponential',echo=FALSE,results='hide'>>=
par(mar=c(4,4,2,1))
plot(A, xlim=c(-8,8), xlab=expression(x), ylab=expression(alpha))
plot(A^2, add=TRUE, col=2, lty=2)
plot(A^3, add=TRUE, col=4, lty=4)
legend('topright', expression(A, A^2, A^3), lty=c(1,2,4), col=c(1,2,4))
@
\end{center}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%





\section{Approximation of Fuzzy Numbers}\label{Sec:Approximation}


Complicated membership functions
are often very inconvenient for processing imprecise information modeled by
fuzzy numbers. Moreover, handling too complex membership
functions entails difficulties in interpretation of the results
too. This is the reason why a suitable approximation of fuzzy
numbers is so important. We would like to deal
with functions that are
simpler or more regular and hence more convenient for
computing.

\subsection{Metrics in the Space of Fuzzy Numbers}

It seems that the most suitable metric for approximation problems
is an extension of the Euclidean ($L_2$) distance
(cf.~\cite{Grzegorzewski1998:metricsordersfn}), $d$, defined by the equation:
\begin{equation}
d_E^2(A,B) = \int_0^1 \left(A_L(\alpha)-B_L(\alpha)\right)^2\,d\alpha
         + \int_0^1 \left(A_U(\alpha)-B_U(\alpha)\right)^2\,d\alpha.
\end{equation}

% TO BE DONE...

The following metric \argument{type}s are currently
available in the \func{distance()} method: \str{"{}Euclidean"{}} (default),
\str{"{}EuclideanSquared"{}}.

<<TrapDist>>=
T1 <- TrapezoidalFuzzyNumber(-5, 3, 6, 20)
T2 <- TrapezoidalFuzzyNumber(-4, 4, 7, 21)
distance(T1, T2, type='Euclidean') # L2 distance /default/
distance(T1, T2, type='EuclideanSquared') # Squared L2 distance
@







\subsection{Approximation by Trapezoidal Fuzzy Numbers}

Our main task in this section is to, given a fuzzy number $A$,
seek for a trapezoidal fuzzy number $\mathcal{T}(A)$
that fulfills some desired properties.
We will use the following FN
for the sake of illustration:

<<ApproxExA>>=
A <- FuzzyNumber(-5, 3, 6, 20,
   left=function(x) pbeta(x,0.4,3),
   right=function(x) 1-x^(1/4),
   lower=function(alpha) qbeta(alpha,0.4,3),
   upper=function(alpha) (1-alpha)^4
)
@

The approximation procedure has been implemented
in \func{trapezoidalApproximation()}.
The \argument{method} argument selects the algorithm used
to project $A$ into the space of TFNs.

\subsubsection{Na\"{i}ve Approximation}

The \str{"{}Naive"{}} \argument{method} just
generates a trapezoidal FN with the same
core and support as $A$.

<<ApproxExA_naive,dependson='ApproxExA',fig.keep='none'>>=
(T1 <- trapezoidalApproximation(A, method='Naive'))
distance(A, T1)
@

\begin{center}
<<ApproxExA_naive2,dependson='ApproxExA_naive',echo=FALSE>>=
par(mar=c(4,4,2,1))
plot(A, xlab=expression(x), ylab=expression(alpha))
plot(T1, col='red', lty=2, add=TRUE)
legend('topright', legend=expression(A, 'Naive approx.'),
   col=c('black', 'red'), lty=c(1,2))
@
\end{center}

It is easily seen that the na\"{i}ve approximator
may not represent $A$ well.
Thus, we will often need some more reasonable
approach.


\subsubsection{$L_2$-nearest Approximation}




% $L_2$ distance....

The \str{"{}NearestEuclidean"{}} \argument{method}
gives the nearest $L_2$-approximation of $A$
\cite[Corollary 8]{Ban2009:nearestfnrev},
i.e.~a trapezoidal fuzzy number $\mathcal{T}(A)$ such that
\[
\mathcal{T}(A)=\min\limits_{T\in \mathrm{TFN}}d_E(A,T).
\]
It may be shown that the solution to this problem
always exists and is unique.

<<ApproxExA_L2n,dependson='ApproxExA',fig.keep='none'>>=
(T2 <- trapezoidalApproximation(A, method='NearestEuclidean'))
distance(A, T2)
@

\begin{center}
<<ApproxExA_naiveL2n2,dependson='ApproxExA_L2n',echo=FALSE>>=
par(mar=c(4,4,2,1))
plot(A, xlab=expression(x), ylab=expression(alpha))
plot(T2, col='red', lty=2, add=TRUE)
legend('topright', legend=expression(A, L[2]-"nearest approx."),
   col=c('black', 'red'), lty=c(1,2))
@
\end{center}

Note that the implementation relies on numeric integration.

\subsubsection{Expected Interval Preserving Approximation}


The \str{"{}ExpectedIntervalPreserving"{}} method
gives the nearest $L_2$-approximation of $A$
preserving the expected interval \cite{Ban2008:approxpresexpint,Grzegorzewski2010:trapfnapproxexpint,Yeh2008:traptriapprox},
i.e.~we get $\mathcal{T}(A)$ such that $\mathrm{EI}(A)=\mathrm{EI}(\mathcal{T}(A))$.

First of all, it may be shown that if $\mathrm{amb}(A) \ge \mathrm{width}(A)/3$, then
we obtain the same result as in
the \str{"{}NearestEuclidean"{}} method.

% TO BE DONE...

<<ApproxExA_ExpInt,dependson='ApproxExA',fig.keep='none'>>=
ambiguity(A)
width(A)/3
(T3 <- trapezoidalApproximation(A, method='ExpectedIntervalPreserving'))
distance(A, T3)
expectedInterval(A)
expectedInterval(T3)
@

% \begin{center}
<<ApproxExA_ExpInt2,dependson='ApproxExA_ExpInt',eval=FALSE,echo=FALSE>>=
par(mar=c(4,4,2,1))
plot(A, xlab=expression(x), ylab=expression(alpha))
plot(T3, col='red', lty=2, add=TRUE)
@
% \end{center}

On the other hand, for highly skewed membership functions this method
(as well as the previous one)  sometimes reveals quite unfavorable
behavior. E.g.~if $B$ is a FN such that
$\mathrm{val}(B) < \mathrm{EV}_{1/3}(B)$
or $\mathrm{val}(B) > \mathrm{EV}_{2/3}(B)$,
then it may happen that the cores of the output
and of the original fuzzy number $B$ are disjoint,
cf.~\cite{GrzegorzewskiPasternak2011:trapapproxsupcore}.

<<ApproxExA_ExpInt3,fig.keep='none'>>=
(B  <- FuzzyNumber(1, 2, 3, 45,
   lower=function(x) sqrt(x),
   upper=function(x) 1-sqrt(x)))
(TB1 <- trapezoidalApproximation(B, 'NearestEuclidean'))
(TB2 <- trapezoidalApproximation(B, 'ExpectedIntervalPreserving'))
distance(B, TB1)
distance(B, TB2)
@

\begin{center}
<<ApproxExA_ExpInt3Fig,dependson='ApproxExA_ExpInt3',echo=FALSE>>=
par(mar=c(4,4,2,1))
plot(B, xlab=expression(x), ylab=expression(alpha), log='x', xlim=c(0.9,46))
plot(TB1, col='red',  lty=2, add=TRUE)
plot(TB2, col='blue', lty=3, add=TRUE)
legend('topright', expression(mu[B], mu[TB[1]], mu[TB[2]]),
   col=c('black', 'red', 'blue'), lty=c(1,2,3))
@
\end{center}


\subsubsection{Approximation with Restrictions on Support and Core}


The \str{"{}SupportCoreRestricted"{}} \argument{method}
was proposed in \cite{GrzegorzewskiPasternak2011:trapapproxsupcore}.
It gives the $L_2$-nearest trapezoidal approximation $\mathcal{T}(A)$
with constraints:
$\mathrm{core}(A) \subseteq \mathrm{core}(\mathcal{T}(A))$
and $\mathrm{supp}(\mathcal{T}(A)) \subseteq \mathrm{supp}(A)$,
i.e.~for which each point that surely belongs to $A$ also belongs to $\mathcal{T}(A)$,
and each point that surely does not belong to $A$ also does not belong to $\mathcal{T}(A)$.

<<ApproxExA_RestrSuppCore,dependson='ApproxExA',fig.keep='none'>>=
(T4 <- trapezoidalApproximation(A, method='SupportCoreRestricted'))
distance(A, T4)
@

\begin{center}
<<ApproxExA_RestrSuppCore2,dependson='ApproxExA_RestrSuppCore',echo=FALSE>>=
par(mar=c(4,4,2,1))
plot(A, xlab=expression(x), ylab=expression(alpha))
plot(T4, col='red', lty=2, add=TRUE)
legend('topright', legend=expression(A, 'Supp&core restr.'),
   col=c('black', 'red'), lty=c(1,2))
@
\end{center}




\subsection{Approximation by Piecewise Linear Fuzzy Numbers}

When approximating arbitrary fuzzy numbers by trapezoidal ones we
generally take care for the core and support of a fuzzy number
(i.e.~for values that surely belong or do not belong at all to the
set under study), while the sides of a fuzzy number corresponding
to all intermediate degrees of membership are linearized. This
approach may not be suitable if we are also interested in focusing
on some other degrees of uncertainty except for 0 or 1.

Thus, given a fuzzy number $A$ and a fixed
\argument{knot.alpha}=$\boldsymbol\alpha$ vector, we are interested in
finding a piecewise linear fuzzy number $\mathcal{P}(A)$
that has some desirable properties.

In this subsection we will use the following fuzzy number $A$
for the sake of illustration:

<<ApproxExAPLFN>>=
A <- FuzzyNumber(-5, 3, 6, 20,
   left=function(x) pbeta(x,0.4,3),
   right=function(x) 1-x^(1/4),
   lower=function(alpha) qbeta(alpha,0.4,3),
   upper=function(alpha) (1-alpha)^4
)
@


The approximation procedure has been implemented
in \func{piecewiseLinearApproximation()}.
The \argument{method} argument selects the algorithm used
to project $A$ into the space of PLFNs (for given \argument{knot.alpha}).

\subsubsection{Na\"{i}ve Approximation}

The \str{"{}Naive"{}} \argument{method} generates a PLFN with the same
core and support as $A$ and with sides interpolating the membership function
of $A$ at given $\alpha$-cuts.

<<ApproxPLFNNaive,dependson='ApproxExAPLFN',fig.keep='none'>>=
P1 <- piecewiseLinearApproximation(A, method='Naive',
         knot.n=1, knot.alpha=0.5)
P1['allknots']
print(distance(A, P1), 8)
@

\begin{center}
<<ApproxPLFNNaive2,dependson='ApproxPLFNNaive',echo=FALSE>>=
par(mar=c(4,4,2,1))
plot(A, xlab=expression(x), ylab=expression(alpha))
plot(P1, col='red', lty=2, add=TRUE)
legend('topright', legend=expression(A, 'Naive approx.'),
   col=c('black', 'red'), lty=c(1,2))
@
\end{center}

\noindent
The approximation error may be quite high.
However, it may be shown that e.g.~for equidistant knots if
$\mathtt{knot.n}\to\infty$,
then it approaches $0$.

\subsubsection{$L_2$-nearest Approximation}

% \paragraph{Exact algorithm for fixed \argument{knot.alpha}.}

Similarly to the $L_2$-nearest TFN case, here we are looking for
\[
\mathcal{P}(A)=\min\limits_{T\in \mathrm{PLFN}(\boldsymbol\alpha)}d_E(A,T).
\]
It may be shown that the solution to this problem
always exists and is unique, see \cite{CoroianuETAL2013:piecewise1}
and \cite{CoroianuETALXXXX:piecewise2}.

The \str{"{}NearestEuclidean"{}} \argument{method}
uses the algorithm described in \cite{CoroianuETAL2013:piecewise1}
and \cite{CoroianuETALXXXX:piecewise2}.
This implementation relies on numeric integration, so for large \argument{knot.n}
may be slow.

<<ApproxPLFNNearest,dependson='ApproxExAPLFN',fig.keep='none'>>=
P2 <- piecewiseLinearApproximation(A,
   method='NearestEuclidean', knot.n=3, knot.alpha=c(0.25,0.5,0.75))
print(P2['allknots'], 6)
print(distance(A, P2), 12)
@

\begin{center}
<<ApproxPLFNNearest2,dependson='ApproxPLFNNearest',echo=FALSE>>=
par(mar=c(4,4,2,1))
plot(A, xlab=expression(x), ylab=expression(alpha))
plot(P2, col='red', lty=2, add=TRUE)
legend('topright', legend=expression(A, L[2]-"nearest approx."),
   col=c('black', 'red'), lty=c(1,2))
@
\end{center}



% \bigskip
% Beware of numerical error in integration e.g.~due to discontinuity
% in $\alpha$-cuts........
% ..... TO BE DONE....
%
% <<PLFNApproxNeares_error,fig.keep='none',warning=FALSE>>=
% A1 <- FuzzyNumber(0,1,1,1,
%          lower=function(a) floor(3*a)/3,
%          upper=function(a) 1-a
% ) # no info on discontinuities
%
% A2 <- DiscontinuousFuzzyNumber(0,1,1,1,
%          lower=function(a) floor(3*a)/3,
%          upper=function(a) 1-a,
%          discontinuities.lower=c(0, 1/3, 2/3, 1),
%          discontinuities.upper=numeric(0)
% ) # discontinuities info included
%
% a <- seq(1e-9, 1-1e-9, length.out=100) # many alphas from (0,1)
% d1 <- numeric(length(a)) # distances #1 (to be calculated)
% d2 <- numeric(length(a)) # distances #2 (to be calculated)
% for (i in 1:length(a))
% {
%    P1 <- piecewiseLinearApproximation(A1, method='NearestEuclidean',
%             knot.n=1, knot.alpha=a[i])
%    P2 <- piecewiseLinearApproximation(A2, method='NearestEuclidean',
%             knot.n=1, knot.alpha=a[i])
%
%    d1[i] <- distance(A1, P1)
%    d2[i] <- distance(A2, P2)
% }
% @
%
% We note that in the first case the distance for $\alpha=0$ (trapezoidal
% approximation) is
% smaller than e.g.~for $\alpha\simeq 0.05$, which, theoretically,
% is not possible. Moreover, the distance is not continuous
% at some $\alpha$ (but it is in theory).
% % .. TO DO.....
%
% \begin{center}
% <<PLFNApproxNeares_error2,dependson='PLFNApproxNeares_error',echo=FALSE>>=
% matplot(a, cbind(d1, d2), type='l', xlab='$\\alpha$', ylab='')
% legend('top', c('$d(A_1,P_1)$', '$d(A_2,P_2)$'), lty=c(1,2), col=c(1,2))
% @
% \end{center}


\paragraph{Example: Convergence.}
As the na\"{i}ve approximator's error approaches 0 as $\text{\argument{knot.n}}\to \infty$
for equidistant knots, so does the error of the nearest $L_2$ approximator.
Let us study the convergence behavior for our exemplary $A$.

<<ApproxPLFNNearestConv1,dependson='ApproxPLFNNearest2',fig.keep='none'>>=
n <- 1:27
d <- matrix(NA, ncol=4, nrow=length(n))
# d[,1] - Naive approximator's error for given knot.n
# d[,2] - Best L2 approximator's error
# d[,3] - theoretical upper bound
for (i in seq_along(n))
{
   P1 <- piecewiseLinearApproximation(A, method='Naive',
            knot.n=n[i]) # equidistant knots
   P2 <- piecewiseLinearApproximation(A, method='NearestEuclidean',
            knot.n=n[i]) # equidistant knots
   d[i,1] <- distance(A, P1)
   d[i,2] <- distance(A, P2)

   acut <- alphacut(A, seq(0, 1, length.out=n[i]+2))
   # d[i,3] <- sqrt(sum((c(diff(acut[,1]), diff(acut[,2]))^2)/(n[i]+1))) # beter ubound
   d[i,3] <- sqrt(2)*max(abs(c(diff(acut[,1]), diff(acut[,2]))))
}
matplot(n, d, type='l', log="y", lty=c(1,2,4), col=c(1,2,4))
@

\begin{center}
<<ApproxPLFNNearestConv2,dependson='ApproxPLFNNearestConv1',echo=FALSE>>=
par(mar=c(4,4,2,1))
matplot(n, d, type='l', xlab=expression(n), ylab=expression(d(A, '*')), log="y", lty=c(1,2,4), col=c(1,2,4))
legend(x=19, y=3.2, expression(d(A, {N^n}(A)), d(A, {Pi^n}(A)), 'upper bound'),
   lty=c(1,2,4), col=c(1,2,4))
@
\end{center}

\paragraph{Example: Finding best \argument{knot.alpha}
for $\text{\argument{knot.n}}=1$ numerically.}
The approximation problem is stated using a fixed
\argument{knit.alpha}.
However, we may e.g.~depict the ``best'' $L_2$ distance as a function of $\alpha$,
i.e.~the $D_{A}(\alpha)$ function.

<<ApproxPLFNNearest3,dependson='ApproxPLFNNearest2',fig.keep='none'>>=
a <- seq(1e-9, 1-1e-9, length.out=100) # many alphas from (0,1)
d <- numeric(length(a)) # distances /to be calculated/
for (i in seq_along(a))
{
   P1 <- piecewiseLinearApproximation(A, method='NearestEuclidean',
            knot.n=1, knot.alpha=a[i])
   d[i] <- distance(A, P1)
}
plot(a, d, type='l', xlab=expression(alpha), ylab=expression(D[A](alpha)))
@

\begin{center}
<<ApproxPLFNNearest4,dependson='ApproxPLFNNearest3',echo=FALSE>>=
par(mar=c(4,4,2,1))
plot(a, d, type='l', xlab=expression(alpha), ylab=expression(D[A](alpha)))
@
\end{center}

For $\text{\argument{knot.n}}=1$ we may find best \argument{knot.alpha} using numerical optimization.
It may be shown, see \cite{CoroianuETAL2013:piecewise1},
that the distance function $D_{A}(\alpha)$ is continuous,
but in general the minimum is not necessarily unique.
% TO DO.....


<<ApproxPLFNNearest5,dependson='ApproxPLFNNearest4',warning=FALSE>>=
for (i in 1:5) # 5 iterations
{
   a0 <- runif(1,0,1) # random starting point
   optim(a0,
      function(a)
      {
         P1 <- piecewiseLinearApproximation(A, method='NearestEuclidean',
                                             knot.n=1, knot.alpha=a)

         distance(A, P1)
      }, method='L-BFGS-B', lower=1e-9, upper=1-1e-9) -> res
   cat(sprintf('%.9f %6g *%.9f* %.9f\n', a0, res$counts[1], res$par, res$value))
}
@



\subsubsection{$L_2$-nearest Approximation Preserving Support and Core}

Fix $\boldsymbol\alpha$. The next method searches for:
\[
\mathcal{P}(A)=\min\limits_{T\in \mathrm{PLFN}(\boldsymbol\alpha)}d_E(A,T).
\]
such that $\mathrm{supp}(A)=\mathrm{supp}(\mathcal{P}(A))$
and $\mathrm{core}(A)=\mathrm{core}(\mathcal{P}(A))$, see
\cite{CoroianuETAL2014:piecewise1suppcore}.

The \str{"{}SupportCorePreserving"{}} \argument{method}
of the \func{piecewiseLinearApproximation()} function
currently implements only the \texttt{\argument{knot.n}==1} case.


\paragraph{Example 1.}
Let us consider the following FN.

<<suppcoreplfn1a>>=
A <- FuzzyNumber(0, 3, 4, 5,
   lower=function(x) qbeta(x, 2, 1),
   upper=function(x) 1-x^3
)
@

Here are its unrestricted ($P_1$) and supp-core-restricted ($P_2$)
PLFN approximations for $\boldsymbol\alpha=(0.2)$.

<<suppcoreplfn1a2,dependson='suppcoreplfn1a'>>=
knot.alpha <- 0.2
P1 <- piecewiseLinearApproximation(A, knot.alpha=knot.alpha)
P2 <- piecewiseLinearApproximation(A, method="SupportCorePreserving",
   knot.alpha=knot.alpha)
distance(A, P1)
print(alphacut(P1, c(0, knot.alpha, 1)))
distance(A, P2)
print(alphacut(P2, c(0, knot.alpha, 1)))
@

\begin{center}
<<suppcoreplfn1a3,dependson='suppcoreplfn1a2',echo=FALSE>>=
par(mar=c(4,4,2,1))
plot(A, xlab=expression(x), ylab=expression(alpha))
plot(P1, col=2, add=TRUE, lty=2)
plot(P2, col=4, add=TRUE, lty=4, lwd=2)
abline(h=knot.alpha, col="grey", lty=3)
legend("topleft", legend=expression(A, P[1], P[2]), lty=c(1,2,4), col=c(1,2,4), lwd=c(1,1,2))
@
\end{center}

Let us find $\alpha_0$ for which we get the minimal approximation
distance (error).

<<suppcoreplfn1a4,dependson='suppcoreplfn1a'>>=
D <- function(a) distance(A,
   piecewiseLinearApproximation(A, method="SupportCorePreserving", knot.alpha=a))
optimize(D, lower=0, upper=1)
@

Note that $D(\alpha)=d_E(A,\mathcal{P}_\alpha(A))$ may not be a well-behaving function, see
\cite{CoroianuETAL2014:piecewise1suppcore} for discussion.

\begin{center}
<<suppcoreplfn1a5,dependson='suppcoreplfn1a4',echo=FALSE>>=
par(mar=c(4,4,2,1))
a <- seq(0, 1, length.out=1001)
Da <- sapply(a, D)
plot(a[-c(1,length(a))], Da[-c(1,length(a))], xlab=expression(alpha), ylab=expression(D(alpha)),
   type='l', xlim=c(0,1), ylim=range(Da))
points(c(0, 1), Da[c(2, length(a)-1)])
points(c(0, 1), Da[c(1,length(a))], pch=16)
opt <- optimize(D, interval=c(0,1))
abline(v=opt$minimum, col="grey", lty=3)
abline(h=opt$objective, col="grey", lty=3)
@
\end{center}

\section{Ranking Fuzzy Numbers in the Setting of Possibility Theory}

There are several possible approaches towards ranking of fuzzy numbers. Dubois and Prade \cite{DuboisPrade1983:rankfn} point out that some are counterintuitive or consider only one point of view on comparing fuzzy numbers. To overcome this issue the set of ranking indices was proposed by Dubois and Prade \cite{DuboisPrade1983:rankfn}. The ranking is done within the framework of Possibility theory which means that for each comparison operator <=, >=, <,> there is a measure of possibility and necessity assessing the truthfulness of the statement (Possibility theory is in detail desribed in \cite{DuboisPrade1986:possbook}). Both measures takes values from the interval [0,1]. Value 1 means complete truthfulness of the statement, 0 means absolute untruthfulness and values in between describe partial truthfulness.

If there are two fuzzy numbers $X$ and $Y$ then the possibility ($\Pi$) and necessity ($\mathcal{N}$) of $X>=Y$ (named exceedance in \package{FuzzyNumbers}) is given by these equations \cite{DuboisPrade1983:rankfn}:
\begin{equation}
\Pi_{X}( [ Y,\infty )) = \underset{x}{\sup} \min ( \mu_{X}(x), \underset{y \leq x}{\sup} \ \mu_{Y} (y) ),
\end{equation}
\begin{equation}
\mathcal{N}_{X}( [ Y,\infty )) = \underset{x}{\inf} \max ( 1 - \mu_{X}(x), \underset{y \leq x}{\sup} \ \mu_{Y} (y) ).
\end{equation}

The possiblity and necessity of $X>Y$ (named strict exceedance in \package{FuzzyNumbers}) are defined as\cite{DuboisPrade1983:rankfn}:
\begin{equation}
\Pi_{X}( ] Y,\infty )) = \underset{x}{\sup} \min ( \mu_{X}(x), \underset{y \geq x}{\inf} 1 - \mu_{Y} (y) ),
\end{equation}
\begin{equation}
\mathcal{N}_{X}( ] Y,\infty )) = \underset{x}{\inf} \max ( 1-\mu_{X}(x), \underset{y \geq x}{\inf} 1 - \mu_{Y} (y) ).
\end{equation}

Changing the $[ Y,\infty )$ to $( - \infty, Y ]$ etc. in these formulas will produce other four indices indicating $X<=Y$ and $X<Y$ \cite{DuboisPrade1983:rankfn,DuboisPrade1986:possbook}.

Now lets create two \texttt{PiecewiseLinearFuzzyNumber}s that we will be comparing.
<<compareXY1>>=
x = as.PiecewiseLinearFuzzyNumber(TriangularFuzzyNumber(0.2, 1.0, 2.8))
y = as.PiecewiseLinearFuzzyNumber(TriangularFuzzyNumber(0, 1.8, 2.2))
@
We can visualized them together.
<<compareXY1plot,dependson='compareXY1'>>=
plot(x, col=2)
plot(y, col=4, add=TRUE)
@
The comparison if $X>=Y$ is done using functions \func{possibilityExceedance()} and \func{necessityExceedance()}.
<<compareXY1c1,dependson='compareXY1'>>=
possibilityExceedance(x,y)
necessityExceedance(x,y)
@
In the same way we can determine the truthfulness of statement $X>Y$ with functions \func{possibilityStrictExceedance()} and \func{necessityStrictExceedance()}.
<<compareXY1c2,dependson='compareXY1'>>=
possibilityStrictExceedance(x,y)
necessityStrictExceedance(x,y)
@
The image image above shows that there is no clear domination of one of the fuzzy numbers and so tell us the indices.

To assess the inverse situations $X<=Y$ and $X<Y$ the following code can be used.
<<compareXY1c3,dependson='compareXY1'>>=
possibilityUndervaluation(x,y)
necessityUndervaluation(x,y)
possibilityStrictUndervaluation(x,y)
necessityStrictUndervaluation(x,y)
@
The results show that again there is no strict domination of one fuzzy number by another (in such case all the indices would be either 1 or 0). But the values of all indices are higher for $X<=Y$,$X<Y$ than in cases $X>=Y$, $X>Y$. Such outcome can be interpred as $X$ being generally smaller then $Y$ but the result is not conclusive. The amount of uncertainty is desribed by these indices.

A slightly more illustrative example is provided below. Note that third and fourth line provide limits for visualization of fuzzy numbers.
<<compareXY2>>=
x = as.PiecewiseLinearFuzzyNumber(TriangularFuzzyNumber(1.7, 2.7, 2.8), knot.n = 9)
y = as.PiecewiseLinearFuzzyNumber(TriangularFuzzyNumber(0, 1.8, 2.2), knot.n = 9)
min = min(x@a1,y@a1)
max = max(x@a4,y@a4)
plot(x, col=2, xlim = c(min,max))
plot(y, col=4, add=TRUE)
possibilityExceedance(x,y)
necessityExceedance(x,y)
possibilityStrictExceedance(x,y)
necessityStrictExceedance(x,y)
possibilityUndervaluation(x,y)
necessityUndervaluation(x,y)
possibilityStrictUndervaluation(x,y)
necessityStrictUndervaluation(x,y)
@

\section{Minimum and Maximum of Fuzzy Numbers}

In the same way as a minimum and maximum of two crisp numbers can be determined, a minimum and a maximum of two fuzzy numbers can be calculated \cite{KaufmannGupta1985:fuzzybook}. A minimum and maximum of two fuzzy numbers is also a fuzzy number.

The minimum of fuzzy numbers is defined for $\alpha$ cuts as \cite{KaufmannGupta1985:fuzzybook}:
\begin{equation}
A_\alpha \wedge B_\alpha = [A_L(\alpha) \wedge B_L(\alpha), A_U(\alpha) \wedge B_U(\alpha)],
\end{equation}
while the maximum is defined as:
\begin{equation}
A_\alpha \vee B_\alpha = [A_L(\alpha) \vee B_L(\alpha), A_U(\alpha) \vee B_U(\alpha)].
\end{equation}


The definition allows determination of minimum and maximum only for Piecewise Linear Fuzzy Numbers. As such the result is only an approximation, which may cause problems with the result is the number of knots is too small (please see examples in the package help for the functions).

<<minmaxXY,fig.keep='none'>>=
x = as.PiecewiseLinearFuzzyNumber(TriangularFuzzyNumber(-4.8, -3 , -1.5), knot.n = 9)
y = as.PiecewiseLinearFuzzyNumber(TriangularFuzzyNumber(-5.5, -2.5, -1.1), knot.n = 9)
min = min(x@a1,y@a1)
max = max(x@a4,y@a4)
plot(x, col=1, xlim = c(min,max))
plot(y, col=2, add=TRUE)
maxFN = maximum(x,y)
minFN = minimum(x,y)
plot(minFN, col=4)
plot(maxFN, col=6, add=TRUE)
@

\begin{center}
<<minmaxXYFig,dependson='minmaxXY',echo=FALSE,results='hide'>>=
par(mar=c(4,4,2,1))
plot(x, col=1, xlim = c(min,max))
plot(y, col=2, add=TRUE)
legend('topright', expression(x, y), lty=c(1,1), col=c(1,2))
plot(minFN, col=4)
plot(maxFN, col=6, add=TRUE)
legend('topright', expression(min, max), lty=c(1,1), col=c(4,6))
@
\end{center}
% \paragraph{Approximate algorithm [TO BE REMOVED] for fixed \argument{knot.alpha}.}
%
% This method uses a constrained version of the Nelder-Mead algorithm.
% The procedure minimizes the target function numerically
% by calling the \func{optim()} function.
% There is thus no guarantee that it will find to the global minimum
% (it may fall into a neighborhood of a local minimum
% or even fail to converge).
% However, this approach may be used for any number of knots.
%
% TO BE DONE... WORK  ON AN EXACT ALGORITHM IS ALMOST FINISHED.....
%
% <<ApproxMethodPLFN1,dependson='ApproxExAPLFN',fig.keep='none'>>=
% system.time(P3 <- piecewiseLinearApproximation(A,
%    method='ApproximateNearestEuclidean', knot.n=1, knot.alpha=0.5))
% print(P3['allknots'], 6)
% print(distance(A, P3), digits=12)
% @
% \noindent
% Compare with exact solution......
% Please note that a call to this method may be time-consuming.
%
% Another example:
%
% <<ApproxMethodPLFN2,dependson='ApproxExAPLFN',fig.keep='none'>>=
% system.time(P4 <- piecewiseLinearApproximation(A,
%    method='ApproximateNearestEuclidean', knot.n=4,
%    knot.alpha=c(0.2, 0.3, 0.7, 0.9), verbose=TRUE))
% @
%
% \begin{center}
% <<ApproxMethodPLFN3,dependson='ApproxMethodPLFN2',echo=FALSE>>=
% plot(A, xlab=expression(x), ylab=expression(alpha))
% plot(P4, col='red', lty=2, add=TRUE)
% print(distance(A, P4), digits=12)
% @
% \end{center}
%
% If the method fails to converge, you may try to call it
% e.g.~with the \texttt{\argument{optim.control}=\func{list}(\argument{maxit}=\allowbreak{}5000)} parameter
% to allow for greater number of iterations.
%
%
%
% <<fig.keep='none',echo=FALSE,exec=FALSE>>=
% # B <- FuzzyNumber(0, 1, 1, 3,
% #    lower=function(x) sqrt(x), upper=function(x) (1-x)^10)
% #
% # X1 <- piecewiseLinearApproximation(B, knot.n=1, knot.alpha=c(0.5),
% #    method='NearestEuclidean', verbose=TRUE)
% # round(X1['allknots'],3)
% # distance(B, X1)
% #
% # X2 <- piecewiseLinearApproximation(B,
% #    knot.n=1, knot.alpha=c(0.5),
% #    method='ApproximateNearestEuclidean',
% #    optim.control=list(maxit=5000), verbose=TRUE)
% # round(X2['allknots'],3)
% # distance(B, X2) # :-(
% #
% # plot(B, lwd=2)
% # plot(X2, add=TRUE, col=4, lty=2)
% # plot(X1, add=TRUE, col=2)
% # legend('topright',
% #    c('Original', 'Best PLFN (approximate)', 'Best PLFN (exact)'),
% #    col=c(1,4,2), lty=c(1,2,1), lwd=c(2,1,1))
% @



% % \clearpage
% \section{NEWS/CHANGELOG}
%
% % \begin{verbatim}
% <<NEWSread,comment='',echo=FALSE,cache=FALSE>>=
% cat(readLines('../../../NEWS'), sep='\n')
% @
% % \end{verbatim}

\paragraph{Acknowledgments.}
This document has been generated with \LaTeX and the \package{knitr}
package for \R.
Their authors' wonderful work is fully appreciated.
Many thanks to Przemys\l{}aw Grzegorzewski, Lucian Coroianu
and Pablo Villacorta Iglesias for stimulating discussion.



The contribution of Marek Gagolewski was partially supported
by the European Union from resources of the European Social Fund, Project PO KL
``Information technologies: Research and their interdisciplinary
applications'', agreement UDA-POKL.04.01.01-00-051/10-00 (March-June 2013),
and by FNP START Scholarship from the Foundation for Polish Science (2013).



% % \clearpage
% \bibliographystyle{acm}
% % see https://github.com/gagolews/bibliography
% % add 'export BIBINPUTS="/home/gagolews/Publikacje/bibliography"'
% %     to .bashrc
% \bibliography{gagolewski,gagolewski_temp,aggregation,probstat,r,unsorted,fuzzynumbers}

\begin{thebibliography}{10}

\bibitem{Ban2008:approxpresexpint}
{\sc Ban, A.}
\newblock Approximation of fuzzy numbers by trapezoidal fuzzy numbers
  preserving the expected interval.
\newblock {\em Fuzzy Sets and Systems 159\/} (2008), 1327--1344.

\bibitem{Ban2009:nearestfnrev}
{\sc Ban, A.}
\newblock On the nearest parametric approximation of a fuzzy number --
  revisited.
\newblock {\em Fuzzy Sets and Systems 160\/} (2009), 3027--3047.

\bibitem{Bodjanova2005:medianfn}
{\sc Bodjanova, S.}
\newblock Median value and median interval of a fuzzy number.
\newblock {\em Information Sciences 172\/} (2005), 73--89.

\bibitem{Chanas2001:intervapproxfn}
{\sc Chanas, S.}
\newblock On the interval approximation of a fuzzy number.
\newblock {\em Fuzzy Sets and Systems 122\/} (2001), 353--356.

\bibitem{CoroianuETAL2013:piecewise1}
{\sc Coroianu, L., Gagolewski, M., and Grzegorzewski, P.}
\newblock Nearest piecewise linear approximation of fuzzy numbers.
\newblock {\em Fuzzy Sets and Systems 233\/} (2013), 26--51.

\bibitem{CoroianuETALXXXX:piecewise2}
{\sc Coroianu, L., Gagolewski, M., and Grzegorzewski, P.}
\newblock Piecewise linear approximation of fuzzy numbers --
a discussion on algorithms, arithmetic operations and stability of fuzzy number characteristics, 2014.
\newblock Submitted paper.

\bibitem{CoroianuETAL2014:piecewise1suppcore}
{\sc Coroianu, L., Gagolewski, M., Grzegorzewski, P., {Adabitabar Firozja}, M.,
  and Houlari, T.}
\newblock Piecewise linear approximation of fuzzy numbers preserving the
  support and core.
\newblock In {\em Information Processing and Management of Uncertainty in
  Knowledge-Based Systems, Part II\/} (2014), A.~Laurent et~al., Eds.,
  vol.~443, Springer, pp.~244--254.

\bibitem{DelgadoETAL1998:canonicalfn}
{\sc Delgado, M., Vila, M., and Voxman, W.}
\newblock On a canonical representation of a fuzzy number.
\newblock {\em Fuzzy Sets and Systems 93\/} (1998), 125--135.

\bibitem{DiamondKloeden1994:metricspacesfs}
{\sc Diamond, P., and Kloeden, P.}
\newblock {\em Metric spaces of fuzzy sets. {T}heory and applications}.
\newblock World Scientific, Singapore, 1994.

\bibitem{DuboisPrade1978:opfn}
{\sc Dubois, D., and Prade, H.}
\newblock Operations on fuzzy numbers.
\newblock {\em Int. J. Syst. Sci. 9\/} (1978), 613--626.

\bibitem{DuboisPrade1983:rankfn}
{\sc Dubois, D., and Prade, H.}
\newblock Ranking Fuzzy Numbers in the Setting of Possibility Theory.
\newblock {\em Information Sciences. 30\/} (1983), 183--224.

\bibitem{DuboisPrade1986:possbook}
{\sc Dubois, D., and Prade, H.}
\newblock {\em {P}ossibility {T}heory: {A}n approach to {C}omputerized {P}rocessing of {U}ncertainty.}.
\newblock Plenum Press, New York, 1986.

\bibitem{DuboisPrade1987:fnoverview}
{\sc Dubois, D., and Prade, H.}
\newblock Fuzzy numbers: An overview.
\newblock In {\em In: Analysis of Fuzzy Information. Mathematical Logic, vol.
  I}. CRC Press, 1987, pp.~3--39.

\bibitem{DuboisPrade1987:meanfn}
{\sc Dubois, D., and Prade, H.}
\newblock The mean value of a fuzzy number.
\newblock {\em Fuzzy Sets and Systems 24\/} (1987), 279--300.

\bibitem{Gagolewski:fuzzynumberspackage}
{\sc Gagolewski, M.}
\newblock {\em {\texttt{FuzzyNumbers}}: {T}ools to deal with fuzzy numbers in
  \textsf{R}}, 2014.
\newblock {h}ttp://FuzzyNumbers.rexamine.com.

\bibitem{Grzegorzewski1998:metricsordersfn}
{\sc Grzegorzewski, P.}
\newblock Metrics and orders in space of fuzzy numbers.
\newblock {\em Fuzzy Sets and Systems 97\/} (1998), 83--94.

\bibitem{Grzegorzewski2010:trapfnapproxexpint}
{\sc Grzegorzewski, P.}
\newblock Algorithms for trapezoidal approximations of fuzzy numbers preserving
  the expected interval.
\newblock In {\em Foundations of Reasoning Under Uncertainty\/} (2010),
  B.-M.~B. et~al, Ed., Springer, pp.~85--98.

\bibitem{GrzegorzewskiPasternak2011:trapapproxsupcore}
{\sc Grzegorzewski, P., and Pasternak-Winiarska, K.}
\newblock Trapezoidal approximations of fuzzy numbers with restrictions on the
  support and core.
\newblock In {\em Proc. EUSFLAT/LFA 2011\/} (2011), Atlantic Press,
  pp.~749--756.

\bibitem{KaufmannGupta1985:fuzzybook}
{\sc Kaufmann, A., and Gupta, M.~M.}
\newblock {\em Introduction to {F}uzzy {A}rithmetic}.
\newblock van Nostrand Reinhold Company, New York, 1985.

\bibitem{KlirYuan1995:fuzzybook}
{\sc Klir, G.~J., and Yuan, B.}
\newblock {\em Fuzzy sets and fuzzy logic. {T}heory and applications}.
\newblock Prentice Hall PTR, New Jersey, 1995.

\bibitem{StefaniniSorini2009:eusflat}
{\sc Stefanini, L., and Sorini, L.}
\newblock Fuzzy arithmetic with parametric {LR} fuzzy numbers.
\newblock In {\em Proc. IFSA/EUSFLAT 2009\/} (2009), pp.~600--605.

\bibitem{Yeh2008:traptriapprox}
{\sc Yeh, C.-T.}
\newblock Trapezoidal and triangular approximations preserving the expected
  interval.
\newblock {\em Fuzzy Sets and Systems 159\/} (2008), 1345--1353.

\end{thebibliography}


\end{document}
